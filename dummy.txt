// STEP 1: Define the Rule interface
package com.example.rules;

import java.util.Map;

public interface Rule {
    String name();
    boolean evaluate(Object user, Map<String, Object> params);
    String getErrorMessage();
}


// STEP 2: Define the Rule YAML Configuration classes
package com.example.config;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

@Data
@Component
@ConfigurationProperties(prefix = "rule-engine")
public class RuleEngineProperties {
    private RuleNode ruleSet;

    public interface RuleNode { }

    @Data
    public static class LogicalNode implements RuleNode {
        private String operator; // AND, OR, NOT
        private List<RuleNode> rules;
    }

    @Data
    public static class RuleLeaf implements RuleNode {
        private RuleDefinition rule;
    }

    @Data
    public static class RuleDefinition {
        private String name;
        private String type;
        private boolean enabled;
        private String severity; // HARD or WARNING
        private String errorMessage;
        private Map<String, Object> params;
    }
}


// STEP 3: Define a User model and fallback UserPolicy
package com.example.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class User {
    private Integer age;
    private Integer minAge;
    private String country;
}

@Data
@NoArgsConstructor
@AllArgsConstructor
public class UserPolicy {
    private Integer defaultMinAge;
    private String defaultCountry;
}


// STEP 4: Sample repository for fallback values
package com.example.repo;

import com.example.model.User;
import com.example.model.UserPolicy;
import org.springframework.stereotype.Repository;

@Repository
public class UserPolicyRepository {
    public UserPolicy findPolicyForUser(User user) {
        return new UserPolicy(21, "US");
    }
}


// STEP 5: Implement a Rule using SpEL
package com.example.rules;

import com.example.model.User;
import com.example.model.UserPolicy;
import com.example.repo.UserPolicyRepository;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.stereotype.Component;

import java.util.Map;

@Component
public class AgeRule implements Rule {
    private final UserPolicyRepository policyRepo;
    private final ExpressionParser parser = new SpelExpressionParser();
    private String errorMessage = "";

    public AgeRule(UserPolicyRepository repo) {
        this.policyRepo = repo;
    }

    @Override
    public String name() {
        return "AGE";
    }

    @Override
    public boolean evaluate(Object obj, Map<String, Object> params) {
        User user = (User) obj;
        UserPolicy policy = policyRepo.findPolicyForUser(user);

        String expr = (String) params.get("threshold");
        StandardEvaluationContext context = new StandardEvaluationContext();
        context.setVariable("user", user);
        context.setVariable("policy", policy);

        Integer threshold = parser.parseExpression(expr).getValue(context, Integer.class);
        if (threshold == null) throw new RuntimeException("Threshold could not be determined");

        boolean result = user.getAge() >= threshold;
        if (!result) {
            this.errorMessage = "User age " + user.getAge() + " is less than threshold " + threshold;
        }
        return result;
    }

    @Override
    public String getErrorMessage() {
        return errorMessage;
    }
}


// STEP 6: Rule Engine Service
package com.example.service;

import com.example.config.RuleEngineProperties;
import com.example.rules.Rule;
import com.example.config.RuleEngineProperties.*;
import lombok.Data;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.*;

@Service
@RequiredArgsConstructor
public class RuleEngineService {
    private final RuleEngineProperties properties;
    private final List<Rule> rules;

    public EvaluationResult evaluate(Object payload) {
        EvaluationResult result = new EvaluationResult();
        evaluateNode(properties.getRuleSet(), payload, result);
        return result;
    }

    private boolean evaluateNode(RuleNode node, Object payload, EvaluationResult result) {
        if (node instanceof LogicalNode logic) {
            return switch (logic.getOperator().toUpperCase()) {
                case "AND" -> logic.getRules().stream().allMatch(r -> evaluateNode(r, payload, result));
                case "OR"  -> logic.getRules().stream().anyMatch(r -> evaluateNode(r, payload, result));
                case "NOT" -> logic.getRules().stream().noneMatch(r -> evaluateNode(r, payload, result));
                default     -> throw new IllegalArgumentException("Invalid operator: " + logic.getOperator());
            };
        } else if (node instanceof RuleLeaf leaf) {
            RuleDefinition def = leaf.getRule();
            if (!def.isEnabled()) return true;

            Rule matched = rules.stream()
                .filter(r -> r.name().equalsIgnoreCase(def.getType()))
                .findFirst()
                .orElseThrow(() -> new RuntimeException("Rule not found: " + def.getType()));

            boolean success = matched.evaluate(payload, def.getParams());
            if (!success) {
                String message = def.getErrorMessage() != null ? def.getErrorMessage() : matched.getErrorMessage();
                if ("HARD".equalsIgnoreCase(def.getSeverity())) {
                    result.getHardErrors().put(def.getName(), message);
                } else {
                    result.getWarningErrors().put(def.getName(), message);
                }
            }
            return success;
        } else {
            throw new IllegalStateException("Unknown RuleNode type");
        }
    }

    @Data
    public static class EvaluationResult {
        private Map<String, String> hardErrors = new HashMap<>();
        private Map<String, String> warningErrors = new HashMap<>();

        public boolean isSuccess() {
            return hardErrors.isEmpty();
        }
    }
}


// STEP 7: Sample Controller
package com.example.controller;

import com.example.model.User;
import com.example.service.RuleEngineService;
import com.example.service.RuleEngineService.EvaluationResult;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/evaluate")
@RequiredArgsConstructor
public class RuleEngineController {

    private final RuleEngineService ruleEngine;

    @PostMapping
    public Map<String, Object> evaluate(@RequestBody User user) {
        EvaluationResult result = ruleEngine.evaluate(user);
        return Map.of(
            "success", result.isSuccess(),
            "hardErrors", result.getHardErrors(),
            "warningErrors", result.getWarningErrors()
        );
    }
}


// STEP 8: application.yml
rule-engine:
  rule-set:
    operator: AND
    rules:
      - rule:
          name: "Minimum Age"
          type: "AGE"
          enabled: true
          severity: "HARD"
          errorMessage: "User does not meet minimum age requirement."
          params:
            threshold: "#user.minAge != null ? #user.minAge : #policy.defaultMinAge"
      - operator: OR
        rules:
          - rule:
              name: "Country US"
              type: "COUNTRY"
              enabled: true
              severity: "WARNING"
              errorMessage: "User country is not US."
              params:
                expression: "#user.country == 'US'"
          - rule:
              name: "Country fallback"
              type: "COUNTRY"
              enabled: true
              severity: "WARNING"
              errorMessage: "User country does not match fallback."
              params:
                expression: "#user.country == #policy.defaultCountry"


// STEP 9: CountryRule (SpEL-based)
package com.example.rules;

import com.example.model.User;
import com.example.model.UserPolicy;
import com.example.repo.UserPolicyRepository;
import org.springframework.expression.ExpressionParser;
import org.springframework.expression.spel.standard.SpelExpressionParser;
import org.springframework.expression.spel.support.StandardEvaluationContext;
import org.springframework.stereotype.Component;

import java.util.Map;

@Component
public class CountryRule implements Rule {

    private final UserPolicyRepository repo;
    private final ExpressionParser parser = new SpelExpressionParser();
    private String errorMessage = "";

    public CountryRule(UserPolicyRepository repo) {
        this.repo = repo;
    }

    @Override
    public String name() {
        return "COUNTRY";
    }

    @Override
    public boolean evaluate(Object obj, Map<String, Object> params) {
        User user = (User) obj;
        UserPolicy policy = repo.findPolicyForUser(user);

        String expr = (String) params.get("expression");
        StandardEvaluationContext context = new StandardEvaluationContext();
        context.setVariable("user", user);
        context.setVariable("policy", policy);

        Boolean result = parser.parseExpression(expr).getValue(context, Boolean.class);
        if (Boolean.FALSE.equals(result)) {
            this.errorMessage = "Expression failed: " + expr;
        }
        return Boolean.TRUE.equals(result);
    }

    @Override
    public String getErrorMessage() {
        return errorMessage;
    }
}
